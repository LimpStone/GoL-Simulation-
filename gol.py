# -*- coding: utf-8 -*-
"""GoL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MqjRKWiPQPjlthqGQ1A9Z3jUL8uW2poB
"""

def Counter(N,M,grid):
  #GLOBAL VAR DECLARATION
  global gliders,blocks,blinkers,toads,beacons,beehives,loafs,boats,tubs,LWS,porcent
  #Reseting variables per generation
  gliders = 0
  blocks = 0
  blinkers = 0
  toads=0
  beacons=0
  beehives=0
  loafs=0
  boats=0
  tubs=0
  LWS=0
  for i in range(N):
        for j in range(M):

          Checker2 = np.array([[(grid[(i-1)%N,(j-1)%M]),(grid[i,(j-1)%M])],      #2*2
                              [(grid[(i-1)%N,j]),(grid[i,j])]])/255

          Checker3 = np.array([[(grid[(i-1)%N,(j-1)%M]),(grid[i,(j-1)%M]),(grid[(i+1)%N,(j-1)%M])],      #3*3
                              [(grid[(i-1)%N,j]),(grid[i,j]),(grid[(i+1)%N,j])],
                              [(grid[(i-1)%N,(j+1)%M]),(grid[i,(j+1)%M]),(grid[(i+1)%N,(j+1)%M])]])/255

          Checker4 = np.array([[(grid[(i-2)%N,(j-2)%M]),(grid[(i-1)%N,(j-2)%M]),(grid[i,(j-2)%M]),(grid[(i+1)%N,(j-2)%M])],  #4*4
                              [(grid[(i-2)%N,(j-1)%M]),(grid[(i-1)%N,(j-1)%M]),(grid[i,(j-1)%M]),(grid[(i+1)%N,(j-1)%M])],    
                              [(grid[(i-2)%N,j]),(grid[(i-1)%N,j]),(grid[i,j]),(grid[(i+1)%N,j])],
                              [(grid[(i-2)%N,(j+1)%M]),(grid[(i-1)%N,(j+1)%M]),(grid[i,(j+1)%M]),(grid[(i+1)%N,(j+1)%M])]])/255                              

          #This made me hate my life ¬¬
          Checker5 = np.array([[(grid[(i-2)%N,(j-2)%M]),(grid[(i-1)%N,(j-2)%M]),(grid[i,(j-2)%M]),(grid[(i+1)%N,(j-2)%M]),(grid[(i+2)%N,(j-2)%M])],  #5*5
                              [(grid[(i-2)%N,(j-1)%M]),(grid[(i-1)%N,(j-1)%M]),(grid[i,(j-1)%M]),(grid[(i+1)%N,(j-1)%M]),(grid[(i+2)%N,(j-1)%M])],    
                              [(grid[(i-2)%N,j]),(grid[(i-1)%N,j]),(grid[i,j]),(grid[(i+1)%N,j]),(grid[(i+2)%N,j])],
                              [(grid[(i-2)%N,(j+1)%M]),(grid[(i-1)%N,(j+1)%M]),(grid[i,(j+1)%M]),(grid[(i+1)%N,(j+1)%M]),(grid[(i+2)%N,(j+1)%M])],
                              [(grid[(i-2)%N,(j+2)%M]),(grid[(i-1)%N,(j+2)%M]),(grid[i,(j+2)%M]),(grid[(i+1)%N,(j+2)%M]),(grid[(i+2)%N,(j+2)%M])]])/255
          
          # GLIDERS
          Glider = np.array([[ 0., 0., 1.], 
                             [ 1., 0., 1.], 
                             [ 0., 1., 1.]])
          
          Glider2 = np.array([[ 1.,  0., 1.], 
                              [ 0.,  1., 1.], 
                              [ 0.,  1., 0.]])
          
          Glider3 = np.array([[ 0.,  1., 0.], 
                              [ 0.,  0., 1.], 
                              [ 1.,  1., 1.]])
          
          Glider4 = np.array([[ 1.,  0., 0.], 
                              [ 0.,  1., 1.], 
                              [ 1.,  1., 0.]])
          # BLOCKS
          Block = np.array([[ 1.,  1.], 
                            [ 1.,  1.]])
          #BLINKERS
          Blinker = np.array([[ 0.,  0., 0.], 
                              [ 1.,  1., 1.], 
                              [ 0.,  0., 0.]])
          
          Blinker2 = np.array([[ 0.,  1., 0.], 
                               [ 0.,  1., 0.], 
                               [ 0.,  1., 0.]])
          #TOADS 
          Toad = np.array([[0., 1.,0.,0.], 
                           [0., 1.,1.,0.], 
                           [0., 1.,1.,0.],
                           [0., 0.,1.,0.]])
          
          Toad2 = np.array([[0., 1.,1.,0.], 
                            [1., 0.,0.,0.], 
                            [0., 0.,0.,1.],
                            [0., 1.,1.,0.]])
          
          Toad3 = np.array([[0., 1.,1.,0.], 
                            [0., 0.,0.,1.], 
                            [1., 0.,0.,0.],
                            [0., 1.,1.,0.]])
          
          Toad4 = np.array([[0., 0.,1.,0.], 
                            [0., 1.,1.,0.], 
                            [0., 1.,1.,0.],
                            [0., 1.,0.,0.]])
          #BEACONS 
          Beacon = np.array([[1., 1.,0.,0.], 
                             [1., 1.,0.,0.], 
                             [0., 0.,1.,1.],
                             [0., 0.,1.,1.]])
          
          Beacon2 = np.array([[1., 1.,0.,0.], 
                              [1., 0.,0.,0.], 
                              [0., 0.,0.,1.],
                              [0., 0.,1.,1.]])
          #BEACONS 
          BEEHIVE = np.array([[0., 1.,0.,0.], 
                              [1., 0.,1.,0.], 
                              [1., 0.,1.,0.],
                              [0., 1.,0.,0.]])
          #LOAFS
          Loaf = np.array([[0., 1.,0.,0.], 
                           [1., 0.,1.,0.], 
                           [1., 0.,0.,1.],
                           [0., 1.,1.,0.]])
          #BOATS
          Boat = np.array([[ 1.,  1., 0.], 
                           [ 1.,  0., 1.], 
                           [ 0.,  1., 0.]])
          #TUBS
          Tub = np.array([[ 0.,  1., 0.], 
                          [ 1.,  0., 1.], 
                          [ 0.,  1., 0.]])
          #LWS
          Lws= np.array([[1., 0., 1., 0., 0.], 
                         [0., 0., 0., 1., 0.], 
                         [0., 0., 0., 1., 0.],
                         [1., 0., 0., 1., 0.],
                         [0., 1., 1., 1., 0.]])  
           
          Lws2= np.array([[0., 1., 0., 1., 0.], 
                          [1., 0., 0., 0., 0.], 
                          [1., 0., 0., 0., 0.],
                          [1., 0., 0., 1., 0.],
                          [1., 1., 1., 0., 0.]]) 
          
          Lws3= np.array([[0., 1., 1., 0., 0.], 
                          [1., 1., 1., 0., 0.], 
                          [1., 1., 0., 1., 0.],
                          [0., 1., 1., 1., 0.],
                          [0., 0., 1., 0., 0.]]) 

          Lws4= np.array([[0., 1., 1., 0., 0.], 
                          [0., 1., 1., 1., 0.], 
                          [1., 0., 1., 1., 0.],
                          [1., 1., 1., 0., 0.],
                          [0., 1., 0., 0., 0.]]) 

          #Comparing array values here
          if np.allclose(Checker3,Glider) or np.allclose(Checker3,Glider2) or np.allclose(Checker3,Glider3) or np.allclose(Checker3,Glider4):gliders+=1
          if np.allclose(Checker2,Block):blocks+=1
          if np.allclose(Checker3,Blinker) or np.allclose(Checker3,Blinker2):blinkers+=1
          if np.allclose(Checker4,Toad) or np.allclose(Checker4,Toad2) or np.allclose(Checker4,Toad3) or np.allclose(Checker4,Toad4):toads+=1
          if np.allclose(Checker4,Beacon) or np.allclose(Checker4,Beacon2):beacons+=1
          if np.allclose(Checker4,BEEHIVE):beehives+=1
          if np.allclose(Checker4,Loaf):loafs+=1
          if np.allclose(Checker3,Boat):boats+=1
          if np.allclose(Checker3,Tub):tubs+=1
          if np.allclose(Checker5,Lws) or np.allclose(Checker5,Lws2) or np.allclose(Checker5,Lws3) or np.allclose(Checker5,Lws4):LWS+=1
          
          """ #DEBUG
          if(Checker5.any()): 
            print(Checker5)
            print()"""
          #Getting the porcent here
          porcent =gliders+blocks+blinkers+toads+beacons+beehives+loafs+boats+tubs+LWS
          if porcent == 0 : porcent = 1

from matplotlib.container import ErrorbarContainer
from traitlets import This
from ast import In
from matplotlib import numpy

"""
conway.py 
A simple Python/matplotlib implementation of Conway's Game of Life.
"""

import sys, argparse
import numpy as np
import matplotlib.pyplot as plt 
import matplotlib.animation as animation
from IPython import display
from datetime import date

ON = 255
OFF = 0
vals = [ON, OFF]
gen = 0
enter = "\n"
porcent = 1
#Forms
gliders = 0
blocks = 0
blinkers = 0
toads = 0
beacons = 0
beehives = 0
loafs=0
boats=0
tubs=0
LWS=0


def randomGrid(N,M):
    """returns a grid of NxN random values"""
    return np.random.choice(vals, N*M, p=[0.2, 0.8]).reshape(N, M)

def addGlider(i, j, grid):
    """adds a glider with top left cell at (i, j)"""
    glider = np.array([[0,    0, 255], 
                       [255,  0, 255], 
                       [0,  255, 255]])
    grid[i:i+3, j:j+3] = glider

def addCell(i, j, grid):
    """adds a cell """
    grid[i,j] = ON

def update(frameNum, img, grid, N,M,output):
    # copy grid since we require 8 neighbors for calculation
    # and we go line by line 
    newGrid = grid.copy()

    #Global variable declarations
    global gen,gliders,blocks,blinkers,toads,beacons,beehives,loafs,boats,tubs,LWS,porcent
  
    # TODO: Implement the rules of Conway's Game of Life
    for i in range(N):
        for j in range(M):
          
          total = (grid[(i-1)%N,(j+1)%M]+grid[i,(j+1)%M]+grid[(i+1)%N,(j+1)%M]+   #Total of the surrounding alive cells
                   grid[(i-1)%N,j]+grid[(i+1)%N,j]+
                   grid[(i-1)%N,(j-1)%M]+grid[i,(j-1)%M]+grid[(i+1)%N,(j-1)%M])/255                
          #Rules
          if grid[i, j]  == ON:
            if (total < 2) or (total > 3):
              newGrid[i, j] = OFF
          else:
            if total == 3:
              newGrid[i, j] = ON      

    #OUTPUT GENERATOR PER INTERATION 
    Counter(N,M,grid)   
    output.write("Interation "+str(gen)+enter)
    output.write("--------------------------------"+enter)
    output.write("|         |  COUT  |  PORCENT  |"+enter)
    output.write("--------------------------------"+enter)
    output.write("| GLIDER  |    "+str(gliders)+"   |    "+str(round(gliders/porcent,2))+"    |"+enter)
    output.write("| BLOCKS  |    "+str(blocks) +"   |    "+str( round(blocks/porcent,2))+"    |"+enter)
    output.write("|BLINKERS |    "+str(blinkers) +"   |    "+str(round(blinkers/porcent,2))+"    |"+enter)
    output.write("|  TOADS  |    "+str(toads) +"   |    "+str(round(toads/porcent,2))+"    |"+enter)
    output.write("| BEACON  |    "+str(beacons) +"   |    "+str(round(beacons/porcent,2))+"    |"+enter)
    output.write("|BEEHIVE  |    "+str(beehives) +"   |    "+str(round(beehives/porcent,2))+"    |"+enter)
    output.write("|   LOAF  |    "+str(loafs) +"   |    "+str(round(loafs/porcent,2))+"    |"+enter)
    output.write("|   BOAT  |    "+str(boats) +"   |    "+str(round(boats/porcent,2))+"    |"+enter)
    output.write("|   TUB   |    "+str(tubs) +"   |    "+str(round(tubs/porcent,2))+"    |"+enter)
    output.write("|   LWS   |    "+str(LWS) +"   |    "+str(round(LWS/porcent,2))+"    |"+enter)
    output.write("--------------------------------"+enter+enter)

    # update data
    gen+=1
    img.set_data(newGrid)
    grid[:] = newGrid[:]
    return img,


# main() function
def main():
    # Command line args are in sys.argv[1], sys.argv[2] ..
    # sys.argv[0] is the script name itself and can be ignored
    # parse arguments
    parser = argparse.ArgumentParser(description="Runs Conway's Game of Life system.py.")
    # TODO: add arguments   
    # declare grid
    grid = np.array([])

    #READING INPUT/OUTPUT ASSIGNATION PART
    ReadInput = open('/content/Input.txt','r')  
    ReadOutput = open('/content/Out.txt','w')   

    Text = ReadInput.readlines()
    
    for lines in Text:
      numbers = lines.split(" ")
      if(Text.index(lines) == 0): #Reading the grid size     
        M = int(numbers[0])
        N = int(numbers[1])
        #grid = randomGrid(N,M) #TEST WITH RANDOM 
        grid = np.zeros(N*M).reshape(N, M) #Zeros grid re-shape
      if(Text.index(lines) == 1): #Reading N generations 
        G = int(numbers[0])
      if(Text.index(lines) > 1):  #Reading points
        y = int(numbers[0])
        x = int(numbers[1]) 
        Type = int(numbers[2]) 
        if(Type == 1): 
          addCell(x,y,grid) 
        if(Type == 2):            
          addGlider(x,y,grid)      

    ReadInput.close()

    # set animation update interval
    updateInterval = 200
    #DATE OF SIMULATION
    today = date.today()
    ReadOutput.write("SIMULATION RUN DATE : "+ str(today)+enter)
    # set up animation
    fig, ax = plt.subplots()
    img = ax.imshow(grid, interpolation='nearest') 
    ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N,M,ReadOutput),frames = G, interval=updateInterval)
    plt.show()
    video = ani.to_html5_video()
    
    plt.close()
  
    # embedding for the video
    html = display.HTML(video)
  
    # draw the animation
    display.display(html)
    

# call main
if __name__ == '__main__':
    main()

def InputReadTEST(M,N,G): #Reading input here <--------
    ReadInput = open('Input.txt','r')   
    Text = ReadInput.readlines()
    
    for lines in Text:
      numbers = lines.split(" ")
      if(Text.index(lines) == 0): #Reading the grid size     
        M = int(numbers[0])
        N = int(numbers[1])
        print("W = "+str(M))
        print("H = "+str(N))
      if(Text.index(lines) == 1): #Reading N generations 
        G = int(numbers[0])
        print("G = "+str(G))
      if(Text.index(lines) > 1):  #Reading points
        x = int(numbers[0])
        y = int(numbers[1])
        print("("+str(x)+","+str(y)+")")      
    ReadInput.close()

if __name__ == '__main__':
    InputReadTEST(1,1,1)